import { GoogleGenAI } from "@google/genai";
import type { GeneratedCourse } from "@shared/schema";

const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY || "" });

const GROUNDING_MODELS = [
  "gemini-2.5-pro",
  "gemini-2.5-flash",
];

const FALLBACK_MODELS = [
  "gemini-2.5-flash-lite",
];

interface GenerateOptions {
  prompt: string;
  useGrounding?: boolean;
}

// Helper function to repair JSON with unescaped quotes in content
function repairJSON(jsonStr: string): string {
  // Strategy: Find quoted strings and escape any unescaped quotes inside them
  let result = '';
  let inString = false;
  let escapedNext = false;
  
  for (let i = 0; i < jsonStr.length; i++) {
    const char = jsonStr[i];
    const prevChar = i > 0 ? jsonStr[i - 1] : '';
    
    if (escapedNext) {
      result += char;
      escapedNext = false;
      continue;
    }
    
    if (char === '\\') {
      result += char;
      escapedNext = true;
      continue;
    }
    
    if (char === '"') {
      if (inString) {
        // Exiting a string
        result += char;
        inString = false;
      } else {
        // Entering a string
        result += char;
        inString = true;
      }
      continue;
    }
    
    // If we're inside a string and find an unescaped quote marker, escape it
    if (inString && char === '"' && prevChar !== '\\') {
      result += '\\"';
      continue;
    }
    
    result += char;
  }
  
  return result;
}

async function generateWithFallback(options: GenerateOptions) {
  const { prompt, useGrounding = false } = options;
  let lastError: any = null;
  let usedModel = "";
  let groundingUsed = false;

  const modelSequence = useGrounding 
    ? [...GROUNDING_MODELS, ...FALLBACK_MODELS]
    : [...FALLBACK_MODELS, ...GROUNDING_MODELS];

  for (const model of modelSequence) {
    const isGroundingModel = GROUNDING_MODELS.includes(model);
    const shouldUseGrounding = useGrounding && isGroundingModel;
    
    try {
      console.log(`ü§ñ Trying model: ${model}${shouldUseGrounding ? ' (with Google Search grounding)' : ''}`);
      usedModel = model;
      
      const config: any = {};
      if (shouldUseGrounding) {
        config.tools = [{ googleSearch: {} }];
      }
      
      const response = await ai.models.generateContent({
        model,
        contents: prompt,
        config: Object.keys(config).length > 0 ? config : undefined,
      });

      groundingUsed = shouldUseGrounding;
      console.log(`‚úîÔ∏è  Using model: ${model}${groundingUsed ? ' with grounding' : ''}`);
      return { response, model, groundingUsed };
    } catch (error: any) {
      lastError = error;
      const status = error.status || error.code;
      const message = error.message || String(error);
      
      if (status === 503 || message.includes("overloaded")) {
        console.log(`‚ö†Ô∏è  Model ${model} is overloaded, trying next...`);
      } else if (status === 429) {
        console.log(`‚ö†Ô∏è  Rate limited on ${model}, trying next...`);
      } else if (status === 400 || status === 401) {
        console.log(`‚ö†Ô∏è  Error with ${model}: ${message}, trying next...`);
      } else {
        console.log(`‚ö†Ô∏è  ${model} failed: ${message}, trying next...`);
      }
      
      continue;
    }
  }

  console.error(`‚ùå All models failed. Last error:`, lastError);
  throw lastError || new Error("All models failed to generate content");
}

export async function generateCourse(topic: string): Promise<GeneratedCourse> {
  const currentYear = new Date().getFullYear();
  const currentMonth = new Date().toLocaleString('en-US', { month: 'long' });
  
  const prompt = `You are an expert course designer with access to the internet. Create a comprehensive, up-to-date online course based on the following topic: "${topic}"

IMPORTANT: Search the web for the latest information about "${topic}" to ensure the course content reflects current ${currentYear} best practices, newest tools, frameworks, and industry trends.

Research and include:
- The most current tools, technologies, and methodologies used in ${currentYear}
- Recent developments, updates, and industry changes (as of ${currentMonth} ${currentYear})
- Modern best practices and emerging trends
- Real-world examples from recent case studies or current industry leaders
- Up-to-date statistics, data, and research findings

Generate a detailed course structure with the following requirements:
1. Create a clear, engaging course title that reflects modern practices
2. Write a brief description (2-3 sentences) explaining what students will learn with today's standards
3. Create 4-6 modules that progressively build on each other
4. Each module should have 3-5 lessons
5. Each lesson should have substantial, educational content (at least 3-4 paragraphs)
6. Content should be beginner-friendly but comprehensive
7. Include practical examples, tips, and actionable advice relevant to ${currentYear}
8. Reference specific current tools, platforms, or resources by name where appropriate

**CRITICAL INSTRUCTION: Your entire response MUST be a single valid JSON object. Start with { and end with }. Do not write any explanation, introduction, or text outside the JSON. Every single character of your response must be valid JSON.**

Expected JSON format:
{
  "course_title": "The main title of the course",
  "description": "A brief description of the course",
  "modules": [
    {
      "module_title": "Module 1 Title",
      "lessons": [
        {
          "lesson_title": "Lesson 1 Title",
          "content": "Full lesson content with multiple paragraphs. Include explanations, examples, and practical tips. Make it educational and engaging."
        }
      ]
    }
  ]
}`;

  try {
    console.log(`\nüìö Generating course for topic: "${topic}" (with web search for latest ${currentYear} info)`);
    
    const { response, model, groundingUsed } = await generateWithFallback({
      prompt,
      useGrounding: true,
    });

    console.log(`üìñ Generated with: ${model}${groundingUsed ? ' (grounding enabled)' : ''}\n`);

    const groundingMetadata = (response.candidates?.[0] as any)?.groundingMetadata;
    if (groundingMetadata) {
      const webSearchQueries = groundingMetadata.webSearchQueries || [];
      const groundingChunks = groundingMetadata.groundingChunks || [];
      
      console.log(`üîé Grounding successful!`);
      console.log(`   Web search queries: ${webSearchQueries.length}`);
      console.log(`   Sources found: ${groundingChunks.length}`);
      
      if (webSearchQueries.length > 0) {
        console.log(`\nüîç Search queries executed:`);
        webSearchQueries.forEach((query: string, index: number) => {
          console.log(`  ${index + 1}. ${query}`);
        });
      }
      
      if (groundingChunks.length > 0) {
        console.log(`\nüìñ Top sources used:`);
        groundingChunks.slice(0, 5).forEach((chunk: any, index: number) => {
          const title = chunk.web?.title || 'Unknown source';
          console.log(`  ${index + 1}. ${title}`);
        });
        if (groundingChunks.length > 5) {
          console.log(`  ... and ${groundingChunks.length - 5} more sources`);
        }
      }
    } else {
      console.log(`‚ö†Ô∏è  No grounding metadata returned - content based on model knowledge only`);
    }

    const text = response.text;
    if (!text) {
      throw new Error("Empty response from Gemini");
    }

    console.log(`\nüìù Raw response (first 300 chars): ${text.substring(0, 300)}`);

    let jsonText = text.trim();
    if (jsonText.startsWith("```json")) {
      jsonText = jsonText.slice(7);
    }
    if (jsonText.startsWith("```")) {
      jsonText = jsonText.slice(3);
    }
    if (jsonText.endsWith("```")) {
      jsonText = jsonText.slice(0, -3);
    }
    jsonText = jsonText.trim();

    let parsed;
    try {
      parsed = JSON.parse(jsonText) as GeneratedCourse;
    } catch (parseError: any) {
      console.log(`‚ö†Ô∏è  Initial JSON parse failed, attempting repair...`);
      try {
        const repairedJSON = repairJSON(jsonText);
        parsed = JSON.parse(repairedJSON) as GeneratedCourse;
        console.log(`‚úÖ JSON successfully repaired and parsed`);
      } catch (repairError: any) {
        console.error(`‚ùå JSON parse error: ${repairError.message}`);
        throw repairError;
      }
    }
    
    if (!parsed.course_title || !Array.isArray(parsed.modules)) {
      throw new Error("Invalid course structure");
    }

    console.log(`‚úÖ Course generated successfully: "${parsed.course_title}"`);
    console.log(`   Modules: ${parsed.modules.length}`);
    console.log(`   Total lessons: ${parsed.modules.reduce((sum, m) => sum + m.lessons.length, 0)}\n`);

    return parsed;
  } catch (error) {
    console.error(`‚ùå Failed to generate course for "${topic}":`, error);
    throw new Error("Failed to generate course content. Please try again.");
  }
}

export async function regenerateModule(
  moduleTopic: string,
  courseContext: string
): Promise<{ module_title: string; lessons: { lesson_title: string; content: string }[] }> {
  const currentYear = new Date().getFullYear();
  
  const prompt = `You are an expert course designer with access to the internet. Regenerate a module for a course.

Course context: ${courseContext}
Module topic: ${moduleTopic}

IMPORTANT: Search the web for the latest ${currentYear} information about "${moduleTopic}" to ensure content is current and accurate.

Research and include:
- Current ${currentYear} best practices and methodologies
- Latest tools, frameworks, and industry standards
- Recent developments and emerging trends
- Up-to-date examples and case studies

Create a comprehensive module with:
1. A clear module title reflecting current standards
2. 3-5 lessons with substantial content
3. Each lesson should have 3-4 paragraphs of educational content
4. Include practical examples and actionable advice relevant to ${currentYear}
5. Reference specific current tools or platforms by name

**CRITICAL: Your entire response MUST be valid JSON only. Start with { and end with }. No text, no explanation, no markdown. Every character must be JSON.**

{
  "module_title": "Module Title",
  "lessons": [
    {
      "lesson_title": "Lesson Title",
      "content": "Full lesson content..."
    }
  ]
}`;

  try {
    console.log(`\nüìö Regenerating module: "${moduleTopic}" (with web search)`);
    
    const { response, model, groundingUsed } = await generateWithFallback({
      prompt,
      useGrounding: true,
    });

    console.log(`üìñ Generated with: ${model}${groundingUsed ? ' (grounding enabled)' : ''}\n`);

    const groundingMetadata = (response.candidates?.[0] as any)?.groundingMetadata;
    if (groundingMetadata) {
      const webSearchQueries = groundingMetadata.webSearchQueries || [];
      const groundingChunks = groundingMetadata.groundingChunks || [];
      console.log(`üîé Grounding: ${webSearchQueries.length} searches, ${groundingChunks.length} sources`);
    }

    const text = response.text;
    if (!text) {
      throw new Error("Empty response from Gemini");
    }

    let jsonText = text.trim();
    if (jsonText.startsWith("```json")) jsonText = jsonText.slice(7);
    if (jsonText.startsWith("```")) jsonText = jsonText.slice(3);
    if (jsonText.endsWith("```")) jsonText = jsonText.slice(0, -3);

    const result = JSON.parse(jsonText.trim());
    console.log(`‚úÖ Module regenerated: "${result.module_title}" (${result.lessons.length} lessons)\n`);
    return result;
  } catch (error) {
    console.error(`‚ùå Failed to regenerate module for "${moduleTopic}":`, error);
    throw error;
  }
}

export async function regenerateLesson(
  lessonTopic: string,
  moduleContext: string
): Promise<{ lesson_title: string; content: string }> {
  const currentYear = new Date().getFullYear();
  
  const prompt = `You are an expert course designer with access to the internet. Regenerate a lesson.

Module context: ${moduleContext}
Lesson topic: ${lessonTopic}

IMPORTANT: Search the web for the latest ${currentYear} information about "${lessonTopic}" to ensure content is current and accurate.

Research and include:
- Current ${currentYear} best practices and real-world applications
- Latest tools, techniques, and industry standards
- Recent developments and case studies
- Up-to-date statistics and research findings

Create a comprehensive lesson with:
1. A clear lesson title reflecting current standards
2. 4-5 paragraphs of educational content
3. Include specific, current examples, tips, and practical advice
4. Reference specific tools, platforms, or resources by name where appropriate

**CRITICAL: Your entire response MUST be valid JSON only. Start with { and end with }. No text, no explanation, no markdown. Every character must be JSON.**

{
  "lesson_title": "Lesson Title",
  "content": "Full lesson content with multiple paragraphs..."
}`;

  try {
    console.log(`\nüìù Regenerating lesson: "${lessonTopic}" (with web search)`);
    
    const { response, model, groundingUsed } = await generateWithFallback({
      prompt,
      useGrounding: true,
    });

    console.log(`üìñ Generated with: ${model}${groundingUsed ? ' (grounding enabled)' : ''}\n`);

    const groundingMetadata = (response.candidates?.[0] as any)?.groundingMetadata;
    if (groundingMetadata) {
      const webSearchQueries = groundingMetadata.webSearchQueries || [];
      const groundingChunks = groundingMetadata.groundingChunks || [];
      console.log(`üîé Grounding: ${webSearchQueries.length} searches, ${groundingChunks.length} sources`);
    }

    const text = response.text;
    if (!text) {
      throw new Error("Empty response from Gemini");
    }

    let jsonText = text.trim();
    if (jsonText.startsWith("```json")) jsonText = jsonText.slice(7);
    if (jsonText.startsWith("```")) jsonText = jsonText.slice(3);
    if (jsonText.endsWith("```")) jsonText = jsonText.slice(0, -3);

    const result = JSON.parse(jsonText.trim());
    console.log(`‚úÖ Lesson regenerated: "${result.lesson_title}"\n`);
    return result;
  } catch (error) {
    console.error(`‚ùå Failed to regenerate lesson for "${lessonTopic}":`, error);
    throw error;
  }
}

export async function generateImagePrompt(courseTitle: string): Promise<string> {
  try {
    const prompt = `You are an expert course thumbnail designer for platforms like Udemy and Skillshare. Create a professional thumbnail prompt.

Course title: "${courseTitle}"

Create a prompt following this EXACT structure:
1. LAYOUT: Instructor/person on the RIGHT side, headline text on the LEFT side
2. PERSON: Confident, professional instructor portrait (describe their appearance, attire matching the course topic, friendly expression)
3. LIGHTING: Soft studio lighting on the person, professional look
4. BACKGROUND: Modern gradient or clean backdrop that fits the course topic
5. TEXT: Bold, large headline (2-4 words) on the left with modern styling (3D, glow, or shadow)
6. ACCENT: ONE small relevant icon or visual element near the text

Keep composition CLEAN and BALANCED. The person and text should be clearly separated.

Format: "[background] with [person description] on the right side, [lighting], bold [text style] headline on left reading '[phrase]', [accent element], professional course thumbnail style, ultra clean composition"

Examples:
- For "Python Programming": "Deep blue to purple gradient background, confident young developer in smart casual attire on the right side smiling, soft studio lighting, bold white 3D text with blue glow on left reading 'MASTER PYTHON', small floating code brackets accent, professional course thumbnail style, ultra clean composition"
- For "Digital Marketing": "Vibrant coral to orange gradient, professional marketing expert in business attire on the right side with confident pose, warm studio lighting, bold black text with white outline on left reading 'GROW YOUR BRAND', subtle social media icons floating, professional course thumbnail style, ultra clean composition"
- For "Fitness Training": "Dynamic dark gradient with red accents, athletic fitness coach in workout gear on the right side looking motivated, dramatic lighting, bold white 3D text on left reading 'GET FIT NOW', single dumbbell icon accent, professional course thumbnail style, ultra clean composition"
- For "Photography Basics": "Sleek dark grey gradient with bokeh lights, creative photographer holding camera on the right side, cinematic lighting, elegant gold and white text on left reading 'CAPTURE MAGIC', camera lens flare accent, professional course thumbnail style, ultra clean composition"

Respond with ONLY the prompt, nothing else.`;

    const { response, model: usedModel } = await generateWithFallback({
      prompt,
    });

    console.log(`üìñ Generated with: ${usedModel}`);

    const text = response.text?.trim();
    if (!text) {
      return `a course thumbnail with text "${courseTitle}"`;
    }

    return text;
  } catch (error) {
    console.error("Failed to generate image prompt:", error);
    return `a course thumbnail with text "${courseTitle}"`;
  }
}

const DEAPI_BASE_URL = "https://api.deapi.ai";

async function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export async function generateCourseImageWithDeAPI(prompt: string): Promise<string | null> {
  const apiKey = process.env.DEAPI_API_KEY;
  
  if (!apiKey) {
    console.error("DEAPI_API_KEY is not set");
    return null;
  }

  try {
    console.log("DeAPI: Starting image generation with prompt:", prompt);
    
    const generateResponse = await fetch(`${DEAPI_BASE_URL}/api/v1/client/txt2img`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`,
        "Accept": "application/json"
      },
      body: JSON.stringify({
        prompt: prompt,
        negative_prompt: "blur, darkness, noise, low quality, distorted text, cluttered, messy, too many elements, pixelated, blurry text, illegible text, watermark, amateur, ugly, deformed, bad anatomy, extra limbs, disfigured face, cropped, multiple people, cartoon, anime, illustration, painting, sketch, low resolution",
        model: "ZImageTurbo_INT8",
        loras: [],
        width: 768,
        height: 432,
        guidance: 7.5,
        steps: 20,
        seed: Math.floor(Math.random() * 1000000)
      })
    });

    if (!generateResponse.ok) {
      const errorText = await generateResponse.text().catch(() => "Unknown error");
      console.error("DeAPI generate error:", generateResponse.status, errorText);
      return null;
    }

    const generateData = await generateResponse.json();
    const requestId = generateData?.data?.request_id || generateData?.task_id || generateData?.request_id;
    
    if (!requestId) {
      console.error("DeAPI: No request_id in response:", generateData);
      return null;
    }

    console.log("DeAPI: Got request_id:", requestId);

    const maxAttempts = 60;
    const pollInterval = 2000;

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      await sleep(pollInterval);
      
      const statusResponse = await fetch(`${DEAPI_BASE_URL}/api/v1/client/request-status/${requestId}`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Accept": "application/json"
        }
      });

      if (!statusResponse.ok) {
        console.log("DeAPI: Status check failed, attempt", attempt + 1);
        continue;
      }

      const statusData = await statusResponse.json();
      const status = statusData?.data?.status || statusData?.status;
      console.log("DeAPI: Status:", status);

      if (status === "done" || status === "COMPLETED") {
        const imageUrl = statusData?.data?.result_url || 
                         statusData?.result_url ||
                         statusData?.result?.output_url;
        
        if (imageUrl) {
          console.log("DeAPI: Image generated successfully:", imageUrl);
          
          // Download the image and convert to base64 data URL to avoid expiration
          try {
            const imageResponse = await fetch(imageUrl);
            if (imageResponse.ok) {
              const arrayBuffer = await imageResponse.arrayBuffer();
              const base64 = Buffer.from(arrayBuffer).toString('base64');
              const contentType = imageResponse.headers.get('content-type') || 'image/png';
              const dataUrl = `data:${contentType};base64,${base64}`;
              console.log("DeAPI: Image converted to permanent data URL");
              return dataUrl;
            } else {
              console.error("DeAPI: Failed to download image, returning original URL");
              return imageUrl;
            }
          } catch (downloadError) {
            console.error("DeAPI: Error downloading image:", downloadError);
            return imageUrl;
          }
        } else {
          console.log("DeAPI: Completed but no image URL found:", JSON.stringify(statusData));
          return null;
        }
      } else if (status === "FAILED" || status === "failed" || status === "error") {
        console.error("DeAPI: Generation failed:", statusData?.error || statusData);
        return null;
      } else {
        console.log("DeAPI: Still processing, attempt", attempt + 1, "status:", status);
      }
    }

    console.error("DeAPI: Timeout waiting for image generation");
    return null;
  } catch (error) {
    console.error("DeAPI request failed:", error);
    return null;
  }
}

export async function generateCourseImage(courseTitle: string): Promise<string | null> {
  try {
    const prompt = await generateImagePrompt(courseTitle);
    console.log("Generating image with prompt:", prompt);
    
    const imageUrl = await generateCourseImageWithDeAPI(prompt);
    return imageUrl;
  } catch (error) {
    console.error("Failed to generate course image:", error);
    return null;
  }
}

export interface ImagePlan {
  imagePrompt: string;
  imageAlt: string;
  placement: number;
}

export interface LessonMediaPlan {
  lessonIndex: number;
  images: ImagePlan[];
}

export interface ModuleMediaPlan {
  moduleIndex: number;
  lessons: LessonMediaPlan[];
}

// Generate a fallback image prompt for a lesson
function generateFallbackImagePrompt(courseTitle: string, moduleTitle: string, lessonTitle: string, lessonContent: string): string {
  const contentPreview = lessonContent.substring(0, 150).replace(/[#*_\n]/g, ' ').trim();
  return `Professional educational illustration for "${lessonTitle}" in a course about "${courseTitle}". Visual concept: ${contentPreview}. Style: clean, modern, minimalist illustration with soft colors. NO TEXT, NO WORDS, NO LABELS, NO CAPTIONS in the image - purely visual elements only. Focus on icons, objects, people, or abstract shapes to represent the concept.`;
}

// Generate a fallback media plan - conservative approach, only add images where truly needed
function generateFallbackMediaPlan(
  courseTitle: string,
  modules: { module_title: string; lessons: { lesson_title: string; content: string }[] }[]
): ModuleMediaPlan[] {
  console.log("Generating conservative fallback media plan for", modules.length, "modules");
  
  // Calculate total lessons to determine how many images to add (roughly 1 per module)
  const totalLessons = modules.reduce((sum, m) => sum + m.lessons.length, 0);
  const targetImages = Math.min(modules.length, Math.ceil(totalLessons / 5)); // ~1 image per 5 lessons
  
  let imagesAdded = 0;
  
  return modules.map((module, moduleIndex) => ({
    moduleIndex,
    lessons: module.lessons.map((lesson, lessonIndex) => {
      const images: ImagePlan[] = [];
      
      // Only add image to first lesson of each module, and only if we haven't exceeded target
      if (lessonIndex === 0 && imagesAdded < targetImages) {
        // Calculate paragraph count to place image after the last paragraph
        const paragraphCount = lesson.content.split(/\n\s*\n/).filter(p => p.trim()).length;
        images.push({
          imagePrompt: generateFallbackImagePrompt(courseTitle, module.module_title, lesson.lesson_title, lesson.content),
          imageAlt: `Illustration for ${lesson.lesson_title}`,
          placement: Math.max(1, paragraphCount), // Place after content, minimum after first paragraph
        });
        imagesAdded++;
      }
      
      return { lessonIndex, images };
    }),
  }));
}

export async function generateCourseMediaPlan(
  courseTitle: string,
  modules: { module_title: string; lessons: { lesson_title: string; content: string }[] }[]
): Promise<ModuleMediaPlan[]> {
  // Count paragraphs for each lesson to help AI decide placement
  const modulesWithParagraphCounts = modules.map((m, mi) => ({
    ...m,
    lessons: m.lessons.map((l, li) => ({
      ...l,
      paragraphCount: l.content.split(/\n\s*\n/).filter(p => p.trim()).length
    }))
  }));

  // Calculate target: roughly 1-2 images per module maximum
  const totalLessons = modules.reduce((sum, m) => sum + m.lessons.length, 0);
  const targetImageCount = Math.max(2, Math.min(modules.length, Math.ceil(totalLessons / 6)));

  const prompt = `You are an expert course designer. Analyze this course and decide which lessons TRULY NEED an image to enhance understanding.

Course: "${courseTitle}"

Modules and Lessons:
${modulesWithParagraphCounts.map((m, mi) => `
Module ${mi + 1}: ${m.module_title}
${m.lessons.map((l, li) => `  Lesson ${li + 1}: ${l.lesson_title} (${l.paragraphCount} paragraphs)
    Content preview: ${l.content.substring(0, 300)}...`).join('\n')}`).join('\n')}

CRITICAL RULES - BE VERY CONSERVATIVE WITH IMAGES:
1. MAXIMUM ONE IMAGE per lesson - NEVER add multiple images to a single lesson
2. Most lessons should have NO images (empty images array)
3. Only add an image if the lesson covers something HIGHLY VISUAL like:
   - Complex diagrams, workflows, or processes that are hard to explain with text
   - Physical objects, tools, or equipment that students need to recognize
   - Step-by-step visual procedures
4. Do NOT add images for:
   - Theoretical concepts that can be explained with text
   - Definitions and terminology
   - Lists, tips, or best practices
   - Introduction or conclusion lessons
5. Target: Add images to only ${targetImageCount} lessons TOTAL across the entire course
6. Image prompts must be visual only - NO TEXT, NO WORDS, NO LABELS in prompts

PLACEMENT RULES:
- placement: 1 = image appears AFTER paragraph 1
- placement: 2 = image appears AFTER paragraph 2
- placement: N = image appears AFTER paragraph N (use the paragraph count to place at the END of the lesson content)
- NEVER use placement: 0 (that puts images BEFORE all content, which looks bad)
- Always set placement to the paragraph count of the lesson to place images AFTER all the text content

Respond ONLY with valid JSON:
{
  "modules": [
    {
      "moduleIndex": 0,
      "lessons": [
        {
          "lessonIndex": 0,
          "images": []
        },
        {
          "lessonIndex": 1,
          "images": [
            {
              "imagePrompt": "Clean minimalist illustration showing [specific visual concept], soft colors, modern style, no text",
              "imageAlt": "Description",
              "placement": 3
            }
          ]
        },
        {
          "lessonIndex": 2,
          "images": []
        }
      ]
    }
  ]
}`;

  try {
    const { response, model: usedModel } = await generateWithFallback({
      prompt,
    });

    console.log(`üìñ Media plan generated with: ${usedModel}`);

    const text = response.text;
    if (!text) {
      console.error("Empty response from Gemini for media plan, using fallback");
      return generateFallbackMediaPlan(courseTitle, modules);
    }

    let jsonText = text.trim();
    if (jsonText.startsWith("```json")) jsonText = jsonText.slice(7);
    if (jsonText.startsWith("```")) jsonText = jsonText.slice(3);
    if (jsonText.endsWith("```")) jsonText = jsonText.slice(0, -3);
    jsonText = jsonText.trim();

    interface OldLessonFormat {
      lessonIndex: number;
      shouldAddImage?: boolean;
      imagePrompt?: string;
      imageAlt?: string;
      placement?: number;
      images?: ImagePlan[];
    }

    interface ParsedModulePlan {
      moduleIndex: number;
      lessons: OldLessonFormat[];
    }

    const parsed = JSON.parse(jsonText) as { modules: ParsedModulePlan[] };
    const mediaPlan = parsed.modules || [];
    
    // Convert to new format and validate
    const validatedPlan: ModuleMediaPlan[] = modules.map((module, moduleIndex) => {
      const existingModulePlan = mediaPlan.find(p => p.moduleIndex === moduleIndex);
      
      if (!existingModulePlan) {
        // Module missing from plan, create fallback
        const fallback = generateFallbackMediaPlan(courseTitle, [module]);
        return { moduleIndex, lessons: fallback[0]?.lessons || [] };
      }
      
      // Convert lessons to new format
      const convertedLessons: LessonMediaPlan[] = module.lessons.map((lesson, lessonIndex) => {
        const lessonPlan = existingModulePlan.lessons.find(l => l.lessonIndex === lessonIndex);
        
        if (!lessonPlan) {
          return { lessonIndex, images: [] };
        }
        
        // Handle both old format (shouldAddImage/imagePrompt) and new format (images array)
        if (lessonPlan.images && Array.isArray(lessonPlan.images)) {
          return { lessonIndex, images: lessonPlan.images };
        } else if (lessonPlan.shouldAddImage && lessonPlan.imagePrompt) {
          // Calculate paragraph count to determine proper placement
          const paragraphCount = lesson.content.split(/\n\s*\n/).filter(p => p.trim()).length;
          return {
            lessonIndex,
            images: [{
              imagePrompt: lessonPlan.imagePrompt,
              imageAlt: lessonPlan.imageAlt || `Illustration for ${lesson.lesson_title}`,
              placement: lessonPlan.placement || Math.max(1, paragraphCount), // Default to after content
            }]
          };
        }
        
        return { lessonIndex, images: [] };
      });
      
      return { moduleIndex, lessons: convertedLessons };
    });
    
    // Only add a single fallback image if the ENTIRE course has zero images
    const totalImages = validatedPlan.reduce((sum, m) => 
      sum + m.lessons.reduce((lSum, l) => lSum + l.images.length, 0), 0);
    
    if (totalImages === 0 && modules.length > 0 && modules[0].lessons.length > 0) {
      // Add just one image to the first lesson of the first module
      const firstLesson = modules[0].lessons[0];
      const paragraphCount = firstLesson.content.split(/\n\s*\n/).filter(p => p.trim()).length;
      validatedPlan[0].lessons[0] = {
        lessonIndex: 0,
        images: [{
          imagePrompt: generateFallbackImagePrompt(courseTitle, modules[0].module_title, firstLesson.lesson_title, firstLesson.content),
          imageAlt: `Illustration for ${firstLesson.lesson_title}`,
          placement: Math.max(1, paragraphCount), // Place after content
        }]
      };
      console.log("Added single fallback image as course had no images");
    }
    
    console.log(`Validated media plan: ${totalImages} images across ${modules.length} modules`);
    return validatedPlan;
  } catch (error) {
    console.error("Failed to generate media plan, using fallback:", error);
    return generateFallbackMediaPlan(courseTitle, modules);
  }
}

export async function generateLessonImage(prompt: string): Promise<string | null> {
  try {
    console.log("Generating lesson image with prompt:", prompt);
    const imageUrl = await generateCourseImageWithDeAPI(prompt);
    return imageUrl;
  } catch (error) {
    console.error("Failed to generate lesson image:", error);
    return null;
  }
}

const NANOBANANA_BASE_URL = "https://api.nanobananaapi.ai";

export async function regenerateImageWithNanoBanana(prompt: string): Promise<string | null> {
  const apiKey = process.env.NANOBANANA_API_KEY;
  
  if (!apiKey) {
    console.error("NANOBANANA_API_KEY is not set");
    return null;
  }

  try {
    console.log("NanoBanana Pro: Starting image regeneration with prompt:", prompt);
    
    // Generate the image using NanoBanana Pro API
    const generateResponse = await fetch(`${NANOBANANA_BASE_URL}/api/v1/nanobanana/generate-pro`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        prompt: prompt,
        resolution: "2K",
        aspectRatio: "16:9",
        callBackUrl: "https://example.com/callback"
      })
    });

    if (!generateResponse.ok) {
      const errorText = await generateResponse.text().catch(() => "Unknown error");
      console.error("NanoBanana generate error:", generateResponse.status, errorText);
      return null;
    }

    const generateData = await generateResponse.json();
    
    if (generateData.code !== 200) {
      console.error("NanoBanana: API returned error code:", generateData);
      return null;
    }
    
    const taskId = generateData?.data?.taskId;
    
    if (!taskId) {
      console.error("NanoBanana: No taskId in response:", generateData);
      return null;
    }

    console.log("NanoBanana: Got taskId:", taskId);

    // Poll for completion
    const maxAttempts = 60;
    const pollInterval = 2000;

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      await sleep(pollInterval);
      
      const statusResponse = await fetch(`${NANOBANANA_BASE_URL}/api/v1/nanobanana/record-info?taskId=${taskId}`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${apiKey}`,
        }
      });

      if (!statusResponse.ok) {
        console.log("NanoBanana: Status check failed, attempt", attempt + 1);
        continue;
      }

      const statusData = await statusResponse.json();
      
      if (statusData.code !== 200) {
        console.log("NanoBanana: Status API error:", statusData);
        continue;
      }
      
      const successFlag = statusData?.data?.successFlag;
      console.log("NanoBanana: Status flag:", successFlag);

      if (successFlag === 1) {
        // SUCCESS - get the image URL
        const imageUrl = statusData?.data?.response?.resultImageUrl || 
                         statusData?.data?.response?.originImageUrl;
        
        if (imageUrl) {
          console.log("NanoBanana: Image generated successfully:", imageUrl);
          
          // Download and convert to base64 data URL for permanence
          try {
            const imageResponse = await fetch(imageUrl);
            if (imageResponse.ok) {
              const arrayBuffer = await imageResponse.arrayBuffer();
              const base64 = Buffer.from(arrayBuffer).toString('base64');
              const contentType = imageResponse.headers.get('content-type') || 'image/png';
              const dataUrl = `data:${contentType};base64,${base64}`;
              console.log("NanoBanana: Image converted to permanent data URL");
              return dataUrl;
            } else {
              console.error("NanoBanana: Failed to download image, returning original URL");
              return imageUrl;
            }
          } catch (downloadError) {
            console.error("NanoBanana: Error downloading image:", downloadError);
            return imageUrl;
          }
        } else {
          console.log("NanoBanana: Completed but no image URL found:", JSON.stringify(statusData));
          return null;
        }
      } else if (successFlag === 2 || successFlag === 3) {
        // FAILED
        console.error("NanoBanana: Generation failed:", statusData?.data?.errorMessage || statusData);
        return null;
      } else {
        // Still processing (successFlag === 0)
        console.log("NanoBanana: Still processing, attempt", attempt + 1);
      }
    }

    console.error("NanoBanana: Timeout waiting for image generation");
    return null;
  } catch (error) {
    console.error("NanoBanana request failed:", error);
    return null;
  }
}
